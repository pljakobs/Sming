diff --git a/OneWire.cpp b/OneWire.cpp
index cb0d670..edce492 100644
--- a/OneWire.cpp
+++ b/OneWire.cpp
@@ -596,8 +596,8 @@ uint16_t OneWire::crc16(const uint8_t* input, uint16_t len, uint16_t crc)
 
 // undef defines for no particular reason
 #ifdef ARDUINO_ARCH_ESP32
-#  undef noInterrupts() {portMUX_TYPE mux = portMUX_INITIALIZER_UNLOCKED;portENTER_CRITICAL(&mux)
-#  undef interrupts() portEXIT_CRITICAL(&mux);}
+#  undef noInterrupts
+#  undef interrupts
 #endif
 // for info on this, search "IRAM_ATTR" at https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-guides/general-notes.html 
 #undef CRIT_TIMING 
diff --git a/OneWire.h b/OneWire.h
index a7bfab7..bc6280b 100644
--- a/OneWire.h
+++ b/OneWire.h
@@ -1,6 +1,14 @@
 #ifndef OneWire_h
 #define OneWire_h
 
+#if defined(ARCH_ESP32)
+#define ARDUINO_ARCH_ESP32
+#elif defined(ARCH_ESP8266)
+#define ARDUINO_ARCH_ESP8266
+#elif defined(ARCH_RP2040)
+#define ARDUINO_ARCH_RP2040
+#endif
+
 #ifdef __cplusplus
 
 #include <stdint.h>
@@ -71,6 +79,7 @@ class OneWire
   public:
     OneWire() { }
     OneWire(uint8_t pin) { begin(pin); }
+    void begin() { } // Do nothing: constructor did actual initialisation
     void begin(uint8_t pin);
 
     // Perform a 1-Wire reset cycle. Returns 1 if a device responds
diff --git a/util/OneWire_direct_gpio.h b/util/OneWire_direct_gpio.h
index a63aae1..42fc9bb 100644
--- a/util/OneWire_direct_gpio.h
+++ b/util/OneWire_direct_gpio.h
@@ -164,97 +164,36 @@ bool directRead(IO_REG_TYPE mask)
 #define IO_REG_BASE_ATTR
 #define IO_REG_MASK_ATTR
 
+#define digitalPinIsValid(pin)   GPIO_IS_VALID_GPIO(pin)
+
 static inline __attribute__((always_inline))
 IO_REG_TYPE directRead(IO_REG_TYPE pin)
 {
-#if CONFIG_IDF_TARGET_ESP32C3 || CONFIG_IDF_TARGET_ESP32C6
-    return (GPIO.in.val >> pin) & 0x1;
-#else // plain ESP32
-    if ( pin < 32 )
-        return (GPIO.in >> pin) & 0x1;
-    else if ( pin < 46 )
-        return (GPIO.in1.val >> (pin - 32)) & 0x1;
-#endif
-
-    return 0;
+    return gpio_ll_get_level(&GPIO, gpio_num_t(pin));
 }
 
 static inline __attribute__((always_inline))
 void directWriteLow(IO_REG_TYPE pin)
 {
-#if CONFIG_IDF_TARGET_ESP32C3 || CONFIG_IDF_TARGET_ESP32C6
-    GPIO.out_w1tc.val = ((uint32_t)1 << pin);
-#else // plain ESP32
-    if ( pin < 32 )
-        GPIO.out_w1tc = ((uint32_t)1 << pin);
-    else if ( pin < 46 )
-        GPIO.out1_w1tc.val = ((uint32_t)1 << (pin - 32));
-#endif
+    gpio_ll_set_level(&GPIO, gpio_num_t(pin), LOW);
 }
 
 static inline __attribute__((always_inline))
 void directWriteHigh(IO_REG_TYPE pin)
 {
-#if CONFIG_IDF_TARGET_ESP32C3 || CONFIG_IDF_TARGET_ESP32C6
-    GPIO.out_w1ts.val = ((uint32_t)1 << pin);
-#else // plain ESP32
-    if ( pin < 32 )
-        GPIO.out_w1ts = ((uint32_t)1 << pin);
-    else if ( pin < 46 )
-        GPIO.out1_w1ts.val = ((uint32_t)1 << (pin - 32));
-#endif
+    gpio_ll_set_level(&GPIO, gpio_num_t(pin), HIGH);
 }
 
 static inline __attribute__((always_inline))
 void directModeInput(IO_REG_TYPE pin)
 {
-#if CONFIG_IDF_TARGET_ESP32C3 || CONFIG_IDF_TARGET_ESP32C6
-    GPIO.enable_w1tc.val = ((uint32_t)1 << (pin));
-#else
-    if ( digitalPinIsValid(pin) )
-    {
-#if ESP_IDF_VERSION_MAJOR < 4      // IDF 3.x ESP32/PICO-D4
-        uint32_t rtc_reg(rtc_gpio_desc[pin].reg);
-
-        if ( rtc_reg ) // RTC pins PULL settings
-        {
-            ESP_REG(rtc_reg) = ESP_REG(rtc_reg) & ~(rtc_gpio_desc[pin].mux);
-            ESP_REG(rtc_reg) = ESP_REG(rtc_reg) & ~(rtc_gpio_desc[pin].pullup | rtc_gpio_desc[pin].pulldown);
-        }
-#endif
-	// Input
-        if ( pin < 32 )
-            GPIO.enable_w1tc = ((uint32_t)1 << pin);
-        else
-            GPIO.enable1_w1tc.val = ((uint32_t)1 << (pin - 32));
-    }
-#endif
+    gpio_ll_output_disable(&GPIO, gpio_num_t(pin));
 }
 
 static inline __attribute__((always_inline))
 void directModeOutput(IO_REG_TYPE pin)
 {
-#if CONFIG_IDF_TARGET_ESP32C3 || CONFIG_IDF_TARGET_ESP32C6
-    GPIO.enable_w1ts.val = ((uint32_t)1 << (pin));
-#else
-    if ( digitalPinIsValid(pin) /* && pin <= 33 */ ) // Use Any In/Out pins 
-    {
-#if ESP_IDF_VERSION_MAJOR < 4      // IDF 3.x ESP32/PICO-D4
-        uint32_t rtc_reg(rtc_gpio_desc[pin].reg);
-
-        if ( rtc_reg ) // RTC pins PULL settings
-        {
-            ESP_REG(rtc_reg) = ESP_REG(rtc_reg) & ~(rtc_gpio_desc[pin].mux);
-            ESP_REG(rtc_reg) = ESP_REG(rtc_reg) & ~(rtc_gpio_desc[pin].pullup | rtc_gpio_desc[pin].pulldown);
-        }
-#endif
-        // Output
-        if ( pin < 32 )
-            GPIO.enable_w1ts = ((uint32_t)1 << pin);
-        else // already validated to pins <= 33
-            GPIO.enable1_w1ts.val = ((uint32_t)1 << (pin - 32));
-    }
-#endif
+    gpio_ll_output_enable(&GPIO, gpio_num_t(pin));
 }
 
 #define DIRECT_READ(base, pin)          directRead(pin)
